# privategrity/crypto/messaging

TBD: This is a proposed redesign and is aspirational at the moment.

The messaging module contains utility functions for preparing,
encrypting, and decrypting messages sent and received by cMix. In cMix
messages are encrypted by the sending clients, partially decrypted by
the nodes, then re-encrypted for the receiving clients by the nodes,
and finally decrypted by the receiving clients. The operational
encrypt/decrypt for each of these operations is the same. There is
also a key selection system driven by a ratcheting protocol.

Any extensions or modifications to the core messaging functionality
should be done here, except for conversion of the encrypted message types
to the comms messages used for transmitting data.


NOTE: This will replace parts of the forward, format, verification, and
schema modules in the original code base.

### Usage

When a client sends a message, they call:

```
salt := NewSalt(csprng, SaltSize)
encryptionKeys := NewEncryptionKeys(salt, baseKeys)
kmacs := NewKMACs(salt, encryptionKeys)
encryptedMessage := EncryptMessage(encryptionKeys, inputMessage)
...
SendMessage(encryptedMessage, salt, kmacs, ...)
```

Then, each server partially decrypts with:

```
salt, kmacs, inputMessage := receiver(...)
...
decryptionKeys := NewDecryptionKeys(salt, []*cyclic.Int{baseKey})
kmac := kmacs[mynodeid]
if ! VerifyKMAC(kmac, salt, decryptionKeys[0]) {
  ... return error
}
partiallyDecryptedMessage := DecryptMessage(decryptionKeys, inputMessage)
```

After cMix's permutation step, the recipient is identified and the
salt is generated by the first node (TODO: should be generated
independently by each node):

```
salt, kmacs, inputMessage := receiver(...)
...
if inputMessage.Salt == nil {
  inputMessage.Salt := NewSalt(csprng, SaltSize)
}
encryptionKeys := NewEncryptionKeys(salt, []*cyclic.Int{baseKey})
kmac := NewKMACs(salt, encryptionKeys)[0]
kmacs = append(kmacs, kmac)
partiallyEncryptedMessage := EncryptMessage(encryptionKeys, inputMessage)
...
SendMessage(salt, kmacs, partiallyEncryptedMessage)
```

Finally, the client can decrypt with:

```
salt, kmacs, inputMessage := receiver(...)
...
decryptionKeys := NewDecryptionKeys(salt, baseKeys)
for i := range kmacs {
  if ! VerifyKMAC(kmac[i], salt, decryptionKeys[i]) {
    .. error
  }
}
decryptedMessage := DecryptMessage(decryptionKeys, inputMessage)
```

## Code Outline

TBD

## Architectual Overview

The client runs a encrypt or decrypt operation that is symmetric to
the operation run on each server. Thus, there is a pattern where the
same function is run on the client as on the server, but the client
performs the operation multiple times, looping over keys shared with
each server. Separately, base key selection and ratcheting algorithms
(key selection) follow the same patterns.

### Keys

For each client and server combination, a shared base key is
established [1], initiated through the user registration process
[2]. The client receives a registration packet with the public keys
and various other information for connecting and encrypting
messages. The client and each node establish a connection and exchange
signed commitments to each other before sending and validating partial base
keys.

The base keys are used to generate a salt which determines a message
key [3]. The message keys (also known as a forward key or reception
key) are created by hashing the base key and the salt together, then
applying a key expansion algorithm.

NOTE: The salt of the first message key is also part of the initial
commitment.

### Encryption and Decryption

Each message contains a Recipient and Message payload. For encryption
and decryption these payloads are treated the same, although
different keys are used to re-encrypt them as they travel through the
cMix network. To encrypt, the key is multiplied into the payload.

While there is a base key shared with each node in the cMix network,
there is only 1 salt per message. Similarly, encrypted messages carry
message authentication codes for each generated key applied to the messages,
so the input message structure is:

```
{
  Message *cyclic.Int
  RecipientID *cyclic.Int
}
```

But the output over the network will be:
```
{
  EncryptedMessage *cyclic.Int
  EncryptedRecipientID *cyclic.Int
  Salt []byte
  KMACs [][]byte
}
```

For simplicity, we assume the same output structure as the input. The
salt and the KMAC list should be handled and verified inside the
client and server side code explicitly.

### API

With all this in mind, the API is as follows:


```
// Clients perform these operations for each node
NewPartialBaseKey(csprng *Rand, group *cyclic.Group) *cyclic.Int
NewSalt(csprng *Rand, size int) []byte
NewEncryptionKeys(salt []byte, baseKeys []*cyclic.Int) []*cyclic.Int
NewDecryptionKeys(salt []byte, baseKeys []*cyclic.Int) []*cyclic.Int

NewKMAC(salt []byte, keys []*cyclic.Int) []byte
VerifyKMAC(salt []byte, keys *cyclic.Int) bool

// Note: Clients send multiple keys, nodes only send 1
encrypt(keys []*cyclic.Int, payload *cyclic.Int)
decrypt(keys []*cyclic.Int, payload *cyclic.Int)
EncryptMessage(encryptionKeys []*cyclic.Int, message *format.Message)
DecryptMessage(decryptionKeys []*cyclic.Int, message *format.Message)
```

* [1] https://docs.google.com/document/d/1uB7dT03K5-rrphkdSDCbDWJ3DtUqHl4imU4kJxoeGto
* [2] https://docs.google.com/document/d/14BfJ5sLc687GqPugIxNU2G2E-soPyYFBGEy-o1xPkn0
* [3] https://docs.google.com/document/d/1fs7aY315KlQJLryyetqTCiDtvtTNYRvr0q1pIaCRXI8
