package broadcast

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/pkg/errors"
	"gitlab.com/elixxir/crypto/rsa"
	"hash"
	"io"
	"strconv"
	"strings"

	jww "github.com/spf13/jwalterweatherman"
	"golang.org/x/crypto/blake2b"
	"golang.org/x/crypto/hkdf"

	"gitlab.com/xx_network/crypto/csprng"
	"gitlab.com/xx_network/primitives/id"

	"gitlab.com/elixxir/crypto/cmix"
)

const (
	version       = 1
	hkdfInfo      = "XX_Network_Broadcast_Channel_HKDF_Blake2b"
	labelConstant = "XX_Network_Broadcast_Channel_Constant"
	saltSize      = 32 // 256 bits
	secretSize    = 32 // 256 bits
)

var channelHash = blake2b.New256

// ErrSecretSizeIncorrect indicates an incorrect sized secret.
var ErrSecretSizeIncorrect = errors.New(
	"NewChannelID secret must be 32 bytes long.")

// ErrSaltSizeIncorrect indicates an incorrect sized salt.
var ErrSaltSizeIncorrect = errors.New(
	"NewChannelID salt must be 32 bytes long.")

// ErrPayloadLengthIsOdd indicates an odd packet payload length.
var ErrPayloadLengthIsOdd = errors.New("Packet payload length must be even.")

// ErrMalformedPrettyPrintedChannel indicates the channel description blob was
// malformed.
var ErrMalformedPrettyPrintedChannel = errors.New(
	"Malformed pretty printed channel.")

// Channel is a multicast communication channel that retains the various privacy
// notions that this mix network provides.
type Channel struct {
	ReceptionID     *id.ID
	Name            string
	Description     string
	Salt            []byte
	RsaPubKeyHash   []byte
	RsaPubKeyLength int
	RSASubPayloads  int
	Secret          []byte

	// Determines the amount of information displayed as plaintext vs encrypted
	// when sharing channel information.
	level PrivacyLevel

	// Only appears in memory; is not contained in the marshalled version.
	// Lazily evaluated on first use.
	//  key = H(ReceptionID)
	key []byte
}

// NewChannel creates a new channel with a variable RSA key size calculated
// based off of recommended security parameters.
func NewChannel(name, description string, level PrivacyLevel,
	packetPayloadLength int, rng csprng.Source) (*Channel, rsa.PrivateKey, error) {
	return NewChannelVariableKeyUnsafe(name, description, level,
		packetPayloadLength, rsa.GetScheme().GetDefaultKeySize(), rng)
}

// NewChannelVariableKeyUnsafe creates a new channel with a variable RSA key
// size calculated to optimally use space in the packer.
//
// Do not use unless you know what you are doing.
//
// maxKeySizeBits received the number of the length of RSA key defining the
// channel in bits. It must be divisible by 8.
//
// packetPayloadLength is in bytes.
func NewChannelVariableKeyUnsafe(name, description string, level PrivacyLevel,
	packetPayloadLength, maxKeySizeBits int, rng csprng.Source) (
	*Channel, rsa.PrivateKey, error) {

	if maxKeySizeBits%8 != 0 {
		return nil, nil, errors.New("maxKeySizeBits must be divisible by 8")
	}

	// Get the key size and the number of fields
	keySize, numSubPayloads := calculateKeySize(
		packetPayloadLength, maxKeySizeBits/8)

	s := rsa.GetScheme()

	// Multiply the key size by 8 because generate expects key size in bits not
	// bytes
	pk, err := s.Generate(rng, keySize*8)
	if err != nil {
		return nil, nil, err
	}
	salt := cmix.NewSalt(rng, saltSize)

	secret := make([]byte, secretSize)
	n, err := rng.Read(secret)
	if err != nil {
		jww.FATAL.Panic(err)
	}
	if n != 32 {
		jww.FATAL.Panic("failed to read from rng")
	}

	pubKeyHash := HashPubKey(pk.Public())

	channelID, err := NewChannelID(
		name, description, level, salt, pubKeyHash, HashSecret(secret))
	if err != nil {
		return nil, nil, err
	}

	return &Channel{
		ReceptionID:     channelID,
		Name:            name,
		Description:     description,
		Salt:            salt,
		RsaPubKeyHash:   pubKeyHash,
		RsaPubKeyLength: keySize,
		RSASubPayloads:  numSubPayloads,
		Secret:          secret,
		level:           level,
	}, pk, nil
}

func UnmarshalChannel(data []byte) (*Channel, error) {
	var c Channel
	return &c, json.Unmarshal(data, &c)
}

// Marshal serialises the Symmetric object into JSON.
func (c *Channel) Marshal() ([]byte, error) {
	return json.Marshal(c)
}

func (c *Channel) label() []byte {
	l := append([]byte(c.Name), []byte(c.Description)...)
	return append(l, []byte(labelConstant)...)
}

// Verify checks that the channel ID is the same one generated by the channel
// primitives.
func (c *Channel) Verify() bool {
	gen, err := NewChannelID(c.Name, c.Description, c.level, c.Salt,
		c.RsaPubKeyHash, HashSecret(c.Secret))
	if err != nil {
		jww.ERROR.Printf(
			"Channel verify failed due to error from channel generation: %+v",
			err)
		return false
	}
	return c.ReceptionID.Cmp(gen)
}

// NewChannelID creates a new channel ID. The resulting 32-byte identity is
// derived like this:
//  intermediary = H(name | description | privacyLevel | rsaPubHash | hashedSecret | salt)
//  identityBytes = HKDF(intermediary, salt, hkdfInfo)
func NewChannelID(name, description string, level PrivacyLevel, salt,
	rsaPubHash, secretHash []byte) (*id.ID, error) {
	if len(salt) != saltSize {
		return nil, ErrSaltSizeIncorrect
	}

	hkdfHash := func() hash.Hash {
		h, err := blake2b.New256(nil)
		if err != nil {
			jww.FATAL.Panic(err)
		}
		return h
	}

	intermediary := deriveIntermediary(
		name, description, level, salt, rsaPubHash, secretHash)
	hkdf1 := hkdf.New(hkdfHash,
		intermediary,
		salt,
		[]byte(hkdfInfo))

	identityBytes := make([]byte, 32)
	n, err := io.ReadFull(hkdf1, identityBytes)
	if err != nil {
		jww.FATAL.Panic(err)
	}
	if n != 32 {
		jww.FATAL.Panic("failed to read from HKDF")
	}

	sid := &id.ID{}
	copy(sid[:], identityBytes)
	sid.SetType(id.User)

	return sid, nil
}

func (c *Channel) MarshalJson() ([]byte, error) {
	return json.Marshal(c)

}

func (c *Channel) UnmarshalJson(b []byte) error {
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	return nil
}

// PrettyPrint prints a human-pasteable serialization of this Channel type.
//
// Example:
//  <XXChannel:v1:"name",description:"blah",math:"qw432432sdfserfwerewrwerewrewrwerewrwerewerwee","qw432432sdfserfwerewrwerewrewrwerewrwerewerwee","qw432432sdfserfwerewrwerewrewrwerewrwerewerwee","qw432432sdfserfwerewrwerewrewrwerewrwerewerwee",>
func (c *Channel) PrettyPrint() string {
	var b strings.Builder
	_, _ = fmt.Fprintf(&b,
		"<Speakeasy-v%d:%s,description:%s,level:%s,secrets:%s,%s,%d,%d,%s>",
		version,
		c.Name,
		c.Description,
		c.level.Marshal(),
		base64.StdEncoding.EncodeToString(c.Salt),
		base64.StdEncoding.EncodeToString(c.RsaPubKeyHash),
		c.RsaPubKeyLength,
		c.RSASubPayloads,
		base64.StdEncoding.EncodeToString(c.Secret))
	return b.String()
}

// NewChannelFromPrettyPrint creates a new Channel given a valid pretty printed
// Channel serialization via the Channel.PrettyPrint method.
func NewChannelFromPrettyPrint(p string) (*Channel, error) {
	fields := strings.FieldsFunc(p, split)
	if len(fields) != 12 {
		return nil, errors.Errorf(
			"%v: number of fields %d does not match expected of %d",
			ErrMalformedPrettyPrintedChannel, len(fields), 12)
	}

	level, err := UnmarshalPrivacyLevel(fields[5])
	if err != nil {
		return nil, errors.Errorf("%v: could not decode privacy level: %+v",
			ErrMalformedPrettyPrintedChannel, err)
	}

	salt, err := base64.StdEncoding.DecodeString(fields[7])
	if err != nil {
		return nil, errors.Errorf("%v: Failed to decode salt: %+v",
			ErrMalformedPrettyPrintedChannel, err)
	}

	rsaPubKeyHash, err := base64.StdEncoding.DecodeString(fields[8])
	if err != nil {
		return nil, errors.Errorf("%v: Failed to decode RSA public key: %+v",
			ErrMalformedPrettyPrintedChannel, err)
	}

	rsaPubKeyLength, err := strconv.Atoi(fields[9])
	if err != nil {
		return nil, errors.Errorf("%v: Failed to decode RSA public key length: %+v",
			ErrMalformedPrettyPrintedChannel, err)
	}

	rsaSubPayloads, err := strconv.Atoi(fields[10])
	if err != nil {
		return nil, errors.Errorf("%v: Failed to decode RSA sub payloads: %+v",
			ErrMalformedPrettyPrintedChannel, err)
	}

	secret, err := base64.StdEncoding.DecodeString(fields[11])
	if err != nil {
		return nil, errors.Errorf("%v: Failed to decode secret: %+v",
			ErrMalformedPrettyPrintedChannel, err)
	}

	c := &Channel{
		Name:            fields[1],
		Description:     fields[3],
		level:           level,
		Salt:            salt,
		RsaPubKeyHash:   rsaPubKeyHash,
		RsaPubKeyLength: rsaPubKeyLength,
		RSASubPayloads:  rsaSubPayloads,
		Secret:          secret,
	}

	c.ReceptionID, err = NewChannelID(c.Name, c.Description, c.level, c.Salt,
		c.RsaPubKeyHash, HashSecret(c.Secret))
	if err != nil {
		return nil, ErrMalformedPrettyPrintedChannel
	}

	return c, nil
}

func split(r rune) bool {
	return r == ',' || r == ':' || r == '>'
}
